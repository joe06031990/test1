// Defines the start of a declarative Jenkins pipeline for restoring Grafana dashboards.
// WARNING: This pipeline runs automatically and will overwrite dashboards without confirmation.
pipeline {
    // Specifies that the pipeline can run on any available Jenkins agent.
    agent any

    // This pipeline is now configured to run automatically on a schedule.
    triggers {
        // 'H * * * *' means the job will run approximately every hour.
        cron('H * * * *')
    }

    // Defines environment variables that will be available throughout the pipeline.
    environment {
        // Securely loads the Grafana API key from Jenkins credentials.
        GRAFANA_API_KEY = credentials('GRAFANA_API_KEY')
        // The URL of your Grafana instance.
        GRAFANA_URL = "https://jstest2025.grafana.net"
        // The name of the root directory where backups are stored in the Git repository.
        GRAFANA_BACKUP_DIR = "playground_nonprd"
    }

    // Contains all the main work stages of the pipeline.
    stages {
        // The first stage: responsible for checking out code from your Git repository.
        stage('Checkout Git Repository') {
            steps {
                // The 'checkout' step clones or updates the specified Git repository and branch.
                // Uses 'scm' to automatically checkout the branch that triggered this build
                checkout scm
            }
        }

        // This stage runs the restore script.
        stage('Run Grafana Restore') {
            steps {
                script {
                    // Define the entire restore script as a Groovy multiline string.
                    def restoreScriptContent = '''
                        #!/bin/bash
                        # 'set -e' ensures the script will exit immediately if a command fails.
                        set -e
                        # 'set -x' prints each command to the log before it is executed, useful for debugging.
                        set -x

                        # Sanity checks to ensure required tools and variables are present.
                        if [ -z "${GRAFANA_URL}" ] || [ -z "${GRAFANA_API_KEY}" ] || [ -z "${GRAFANA_BACKUP_DIR}" ]; then
                            echo "Missing required environment variables (GRAFANA_URL, GRAFANA_API_KEY, GRAFANA_BACKUP_DIR)."
                            exit 1
                        fi

                        if [ ! -d "${GRAFANA_BACKUP_DIR}" ]; then
                            echo "Error: Backup directory '${GRAFANA_BACKUP_DIR}' not found."
                            exit 1
                        fi
                        
                        # --- Safety Check ---
                        # This script is specifically designed to restore the 'playground_nonprd' backup.
                        if [ "$(basename "${GRAFANA_BACKUP_DIR}")" != "playground_nonprd" ]; then
                            echo "Error: This script is configured to only restore the 'playground_nonprd' directory."
                            echo "The target directory is '$(basename "${GRAFANA_BACKUP_DIR}")'. Aborting."
                            exit 1
                        fi

                        echo "Starting Grafana restore from local directory '${GRAFANA_BACKUP_DIR}' to ${GRAFANA_URL}"

                        # This function parses a JSON string to find the value of a given key.
                        extract_json_value() {
                            local json="$1"
                            local key="$2"
                            echo "$json" | awk -F'"' -v key="$key" '
                                {
                                    for(i=1; i<=NF; i++) {
                                        if($i == key && $(i+1) == ":") {
                                            print $(i+2)
                                            break
                                        }
                                    }
                                }'
                        }

                        # Use an associative array to keep track of created folder UIDs to avoid duplicate API calls
                        declare -A FOLDER_UIDS

                        # Function to get or create a Grafana folder and store its UID
                        get_or_create_folder() {
                            local folder_title=$1
                            
                            if [ -n "${FOLDER_UIDS[$folder_title]}" ]; then
                                echo "${FOLDER_UIDS[$folder_title]}"
                                return
                            fi

                            # Search for the folder by title
                            local search_result
                            search_result=$(curl -s -H "Authorization: Bearer ${GRAFANA_API_KEY}" "${GRAFANA_URL}/api/search?type=dash-folder")
                            
                            # Process search results to find a matching folder
                            local folder_uid
                            folder_uid=$(echo "$search_result" | sed 's/^\\[//;s/\\]$//' | sed 's/},{/}\\n{/g' | while read -r folder_info; do
                                current_title=$(extract_json_value "$folder_info" "title")
                                if [ "$current_title" == "$folder_title" ]; then
                                    extract_json_value "$folder_info" "uid"
                                    break
                                fi
                            done)

                            if [ -n "$folder_uid" ]; then
                                echo "Folder '${folder_title}' already exists with UID: ${folder_uid}"
                            else
                                echo "Folder '${folder_title}' not found. Creating it..."
                                local create_payload="{\\"title\\": \\"${folder_title}\\"}"
                                
                                local create_result
                                create_result=$(curl -s -X POST -H "Authorization: Bearer ${GRAFANA_API_KEY}" -H "Content-Type: application/json" --data "$create_payload" "${GRAFANA_URL}/api/folders")
                                
                                folder_uid=$(extract_json_value "$create_result" "uid")
                                
                                if [ -z "$folder_uid" ]; then
                                    echo "Error: Failed to create folder '${folder_title}'. Response: ${create_result}"
                                    exit 1
                                fi
                                echo "Successfully created folder '${folder_title}' with UID: ${folder_uid}"
                            fi
                            
                            FOLDER_UIDS["$folder_title"]=$folder_uid
                            echo "$folder_uid"
                        }

                        # Find all dashboard JSON files in the backup directory and iterate through them
                        find "${GRAFANA_BACKUP_DIR}" -type f -name "*.json" | while read -r dashboard_path; do
                            echo "--- Processing dashboard: ${dashboard_path} ---"
                            
                            dir_path=$(dirname "${dashboard_path}")
                            folder_title=$(basename "${dir_path}")
                            
                            local FOLDER_ID
                            local target_grafana_folder=""

                            if [ "${folder_title}" == "${GRAFANA_BACKUP_DIR}" ]; then
                                target_grafana_folder="Playground"
                            else
                                target_grafana_folder="${folder_title}"
                            fi
                            
                            echo "Target Grafana folder is: '${target_grafana_folder}'"
                            folder_uid=$(get_or_create_folder "${target_grafana_folder}")
                            folder_details=$(curl -s -H "Authorization: Bearer ${GRAFANA_API_KEY}" "${GRAFANA_URL}/api/folders/${folder_uid}")
                            FOLDER_ID=$(extract_json_value "$folder_details" "id")
                            
                            if [ -z "$FOLDER_ID" ]; then
                                echo "Could not determine Folder ID for '${target_grafana_folder}'. Skipping dashboard."
                                continue
                            fi
                            
                            dashboard_json=$(cat "${dashboard_path}")

                            restore_payload=$(printf '{"dashboard": %s, "folderId": %s, "overwrite": true}' "$dashboard_json" "$FOLDER_ID")

                            restore_result=$(curl -s -X POST -H "Authorization: Bearer ${GRAFANA_API_KEY}" -H "Content-Type: application/json" --data-raw "${restore_payload}" "${GRAFANA_URL}/api/dashboards/db")

                            status=$(extract_json_value "$restore_result" "status")
                            if [ "$status" == "success" ]; then
                                echo "Successfully restored dashboard from '${dashboard_path}'"
                            else
                                echo "Error restoring dashboard from '${dashboard_path}'. Response: ${restore_result}"
                            fi
                        done

                        echo "--- Grafana restore process complete. ---"
                    '''
                    
                    // Write the script content to a file in the workspace
                    writeFile(file: 'run_grafana_restore.sh', text: restoreScriptContent)
                    // Make the file executable
                    sh 'chmod +x run_grafana_restore.sh'
                    // Execute the script explicitly with bash to ensure compatibility
                    sh 'bash ./run_grafana_restore.sh'
                }
            }
        }
    }

    // The 'post' section defines actions that run at the end of the pipeline.
    post {
        // 'always' means this action will run regardless of whether the pipeline succeeded or failed.
        always {
            // Clean up the workspace
            deleteDir()
        }
    }
}
